# 我们的 Rust 纯度比 Linux 内核高 99.7%!

# 导览
AEFR 目前并不是一个为了讨好所有人而设计的复杂应用。它只是 600 行直达底层的 Rust 逻辑所构成的一个内核。在计算机的世界里，最短的路径永远是最无敌的。如果你追求的是平庸，请去用 AA；如果你追求的是极致的自由与性能，欢迎来到 AEFR

# AEFR's Eternal Freedom & Rust-rendered
非官方的.粉丝制作的.使用rust制造的.性能强劲的多平台多线程蔚蓝档案二次创作编辑器.不使用游戏引擎.使用eGUI库.支持Linux.Android.MacOS.WIndows

GPL3协议开源，欢迎任何人来帮忙负责开发

现在我们只做到了“一幕”的效果，能更换背景 能导入 5 个骨骼文件，可以“对话”，骨骼文件可以换表情，可以更改背景音乐

# 但是，在提供帮助中，必须要遵守以下规则
技术栈纯洁性：本项目坚持核心业务逻辑与架构 100% 使用 Rust 实现

原则上拒绝引入任何需要与 C++ 运行时或框架（如 Qt、Unity、Unreal 等）进行复杂交互（JNI/复杂FFI）的 PR，以保持架构的纯粹性和可维护性

例外情况：允许为接入现有的、功能完整的、底层系统级C库（如图形、音频、文件系统基础库）而编写 Rust 安全封装层。在此情况下：

必须优先使用社区维护的、成熟的  -sys  绑定库（如  libc 、 openssl-sys ）。

若需自行编写  unsafe  代码进行 FFI 调用，必须严格遵守下文的  unsafe  代码规范，并证明其不可替代性

最终目标是将所有  unsafe  调用封装在安全的 Rust API 之内，对上层应用完全透明

# unsafe准则
 unsafe  代码规范：安全之上的性能之刃

 unsafe  关键字是 Rust 赋予开发者在编译期安全规则之外，进行必要底层操作的能力。本项目视其为 “安全之上的性能之刃” ，使用原则是 “非必要不使用，使用时必须万无一失”

 核心原则：必要性证明

任何  unsafe  代码块的存在，都必须基于一个无法通过安全 Rust 代码实现的正当理由。在提交的 PR 中，您必须在  unsafe  代码块上方，以注释形式提供一份简明的“必要性证明”，内容应至少包括：

原因：明确指出为何必须使用  unsafe （例如：调用特定的 C FFI 函数、进行确定性的内存布局转换、实现某个自引用数据结构等）

不可替代性：论证为何无法用安全的 Rust 标准库或社区库实现相同功能

安全边界：清晰界定该  unsafe  块所承诺维护的不变量。即，作为开发者，您向编译器“承诺”了哪些条件必定成立，从而使得这段代码在逻辑上是安全的

具体要求：注释、绑定与封装

文档化注释：

每个  unsafe  函数、方法或代码块都必须附有前置注释

# GUI改进规则
UI 组件必须遵循  egui  的即时模式哲学，不接受来自  React  风格的提议

# 💾 获取 AEFR
AEFR 没有发布Release的打算

​“Release? Real hackers compile from source.”

源码已发，想要测试，自己去用cargo run --release吧

# 联系我们：
作者邮箱：3997101522@qq.com
